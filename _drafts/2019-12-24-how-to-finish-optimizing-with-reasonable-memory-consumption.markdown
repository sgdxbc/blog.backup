---
title: 减少基本块结构的内存消耗
date: 2019-12-24 15:08
author: sgdxbc
categories: weaver
tags: 编译器 优化
---

![内存消耗突破天际](/assets/Annotation 2019-12-24 150450.png)

> SSD：「撑住！我来了！」CPU：「……你还是算了吧」

在之前的两篇文章中，我介绍了[一种用于优化的基本块数据结构]({% post_url 2019-12-20-a-simple-ir-for-optimizing %})，和[操作基本块的两种算法]({% post_url 2019-12-22-constant-evaluation-and-condition-relocating %})。这些技术在面临问题规模的增长时，时间和空间复杂度都会呈指数增长的趋势，因此限制问题的规模至关重要。这篇文章将讨论如何在（尽量）不影响优化结果的情况下，将问题规模降低至可以接受的程度，并且回答一个读者也许早就想问我的问题：

## （我所定义的）常量分析和分支定位到底进行了什么优化？

我想读者也许早就发现了这个问题。分支定位显然不会进行任何优化；它只能改变程序的执行顺序，而无法消减任何代码。常量分析的结果并没有保存下来，仅仅是将其判断结果可以静态确定的条件分支的判断连同一条本来就永远都不会进入的路径给消除了。如果只是到此为止的话，也许这一系列的文章被称为是「代码尺寸优化」才更加合适一点。

事实上，经过循环执行两种优化以后，程序变形成为一种有趣的等价形式，在这种形式中，**基本块中的指令尽可能地集中了起来**。也就是说，不管你顺着哪一条分支观察程序的执行流程，都会发现，绝大多数的指令都是在一个基本块中被执行掉的，在此之前可能会出现多个空壳基本块，只包含条件判断而不在此之前执行任何指令。

> 当然，只有在原本的程序逻辑允许这种现象发生的那些分支，才会发生这种现象。

这种集中性使我们有机会发掘出原本零散地分布在程序中各处的冗余操作。例如，以下是对一个IP协议解释器的真实实现进行优化后得到的其中一个基本块

```
L5136:
$1001 = 0
$1000 = 0
$1001 = 1
$1001 = 1
$1000 = 0
$101->Create(header->saddr, header->daddr)
$1003 = 0
$102->InsertMeta(header->offset, header_meta->payload_length)
$102->InsertData(header_meta->payload)
$1002 = 0
$102->Assemble()
$101->Set{state}($1000)
$101->Set{seen_dont_frag}($1003)
$0->Next()
$101->Destroy()
```

除去显而易见地对`$1001`的重复赋值（事实上，由于接下来并没有依赖与`$1001`的值的逻辑，所有的赋值都是多余的）以外，我们可以发现一对方法调用：`$101->Create(...)`和`$101->Destroy()`。我们可以基于这个信息，将一个昂贵的`Create`方法调用替换成为一个等价的`Fake`方法——只有在我们知道接下来`Destory`方法会被调用的时候才能这样做！如果这个基本块位于一条执行概率非常大的分支上，那么以上操作将会使程序性能得到巨大提升。

这就是我们执行两种基于基本块的优化的最终目的。

----

程序执行流上每出现一个条件分支，其合并后的所有指令就都需要复制成两份。在一条较长的、途径多个「菱形」结构的控制流上，后续的指令将在基本块中占据极为庞大的内存。因此，如果我们可以将不影响优化结果的条件分支保持为「折叠」状态，就可以节省大量的内存空间和计算时间。比如

```c
int x, y, z;
y = x + 1;
Create();
if (x == 0) {
    z = y;
}
if (x == 1) {
}
if (z == 1) {
    Destory();
}
```