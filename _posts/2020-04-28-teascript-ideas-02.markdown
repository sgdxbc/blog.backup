---
title: 关于TeaScript的原始想法（续）
date: 2020-04-28 11:24
categories: thoughts
tags: TeaScript
---

昨天想了一下内部状态的相关问题，得出了一些结论：
* 内部状态应当允许可变性。否则就不能称之为「状态」了，没有状态也就不能称之为「对象」了。没有可变性的语言设计起来也非常复杂。
* **内部状态应该暴露且仅暴露给与之关联的一组方法。**

详细地说说第二点。内部状态都不是凭空出现的，一定是有方法要使用它它才有存在的必要。强调它的「内部」性就意味着它应当隐含在方法的业务逻辑中，用来使方法的
某次调用在运行时中产生痕迹，而不至于每次调用完都失忆，从而简化一些程序的抽象。一个内部状态所面向的方法群体，应该是在这些方法被创造出来的时候就已经确定
地决定下来了的，一个状态既不应该被更加「古老」的方法知晓，也不应该被还未「诞生」的方法所发现。如果C++程序中所有的实例变量都是`private`的那么基本遵循
这一套规则，事实上这样的限制似乎也没有什么大问题。

这样一来，一个古老的技巧似乎进入了视野：闭包

```
cat = object spawn
  new(name) ->
    name = name  # 需要斟酌
    object spawn
      setName(newName) -> name = newName
      sayHi -> 'Moew, this is ' + name + '.'
```

有两个点值得注意。`new`方法返回的对象并不是`cat spawn`而是`object spawn`。这是因为每一只具体的猫并不需要具有`new`方法。刚一开始`object spawn`会让
带着过去经验的人产生一种「创建了一个`object`类型对象」的错觉。实际上它的语义更接近于「创建了一个继承自`object`的新类型」，只是这个类型同时也是当作
一个对象来使用的。

另一点在于`setName`和`sayHi`方法的位置。哪怕是在Ruby这门同样用了`new`方法来创建新对象的语言中，实例方法也是与类方法一样被挂在类对象的属性字典里的，
只是在被调用时会被绑定不同的上下文对象而已。然而在TeaScript当中，对象的方法只能被挂在对象本身上面，因为只有在这里才有它们所用到的内部状态。这样做会
带来内存开销吗？实际上只要在编译时静态地收集所有`spawn`语句后面跟着的分发表（所以`spawn`不能是一个普通的内建方法），就可以做到在大量对象中复用分发表，
从而避免原生JavaScript使用闭包模拟状态时要面临的多次创建方法函数的问题。

而另一个坏处在于`new`方法所在的缩进层级变得有些尴尬，尤其是当一个「类」没有其他类静态方法的时候。我在考虑一种有点脱线的方案：每个文件都是一个对象。
因此上面的代码基本等价于，在`cat.tea`中写

```
new(name) ->
  name = name
  object spawn
    ; ...
```

----

最后关于`name = name`，我采取了「古典」的Self和Smalltalk的论点，把`new(name)`整体看作是一条消息，因此分发表的定义语法基本上是模拟了Erlang的消息
处理。作为一条「消息」，它携带的参数似乎不宜自动纳入作用域，如果今后我把方法调用拓展到了异步消息发送的地步这个特性会更加有意义。

总感觉可以边实现边继续考虑了。
