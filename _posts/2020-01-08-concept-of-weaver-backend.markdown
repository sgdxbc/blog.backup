---
title: 语法制导与设计模式
date: 2020-01-08 12:24
categories: weaver
tags: 编译器 设计模式
---

基本块数据结构显然既不是起点也不是终点——我不可能要求用户手写`If`和`SetValue`并且手动分配寄存器，并且，基本块本身也没有运行环境——除了我的大脑。事实上，优化过的基本块（们）最终是要编译成C代码然后交给GCC的，这也是为什么我总是在用C语言举例子描述其设计的原因之一——因为我本来就是在用C语言的逻辑去思考的。这篇文章的内容是有关于将基本块编译成一个C代码文件的基本方法，存在的潜在问题，和候选的解决方案。

> 那么前端呢？抱歉，这个可能要等久一点了。不仅仅是我打算最后写它，就算写完了，也要等论文公之于世以后才能写文章哦。

首先要明确的一点：一个基本块不能构成一个完整的程序。与一个「程序」在概念上对应的是一组基本块，它们最初可能是来自于同一次对`BasicBlock.from_codes`的调用，然后传入这次调用的一列指令被分散在了这组基本块中合适的位置上。我们最终只会持有这组基本块中的「入口」基本块，但是可以非常简单地通过基本块的`recurse`方法把这组基本块全部找到。由于这个方法名字的原因我在代码中也将这样的一组基本块称为`recurse`了，事实上用一个动词来形容一个事物还是有点愚蠢的，所以我在文章中将统一称之为基本块簇，简称簇。

那么一个基本块簇就是一个完整的程序了吗？可以是，也可以不是。多个基本块簇可以组成一个更大的程序。比如说，一个簇用来处理一个数据包的以太网包头，另一个簇用来处理IP包头，那么我们很可能希望程序控制流从前一个簇流出后径直流入后一个簇的入口基本块。将这些簇在编译前组装为一个大簇是可行的，但是我觉得没有这样做的必要。

如果你还记得我曾经引用过的，为了调试和介绍基本块而打印出的伪代码序列的话

```
L6:
$1 = 1
$2 = $0 + $1
If $2 == 4 Goto L2 Else Goto L5

L2:
$2 = $2 - $1
If $2 == 3 Goto L0 Else Goto L1

L0:
$2 = $2 - $1

L1:
$2 = $2 + $1

L5:
If $2 == 3 Goto L3 Else Goto L4

L3:
$2 = $2 - $1

L4:
$2 = $2 + $1
```

你会觉得把它翻译成C代码是非常轻而易举的，几乎就是在合适的位置加上变量声明和分号这么简单的事情。（巧了我最初也是这么觉得的。）但是仔细想一下会发现，基本块指令的信息局部性其实不算太好：
* 如上文提到的，一个基本块簇的「出口」基本块需要了解到下一个簇的入口块的编号，这个信息它本身是不会有的
* 几乎每一个`Command`都不可能被简单地翻译，它们经常需要对外部函数进行调用。糟糕的是，有一些被调用的函数也需要被动态生成出来，那么我们不得不保证生成出的函数名字具有全局唯一性，否则无法通过GCC
* 最重要的一点：说到底我们的中间指令只有两种半，而它们用的值类型通通都是`Value`一种类型，这些指令和值肯定不会都用同样的方式进行翻译的，那么更多的信息从哪里来？

我们首先讨论一下最后一个问题。解决它有一个直观的办法，同时也是我上次尝试过的办法：根据实现的不同，给每一种翻译方式的指令和值创建一个子类，在子类中没有中端优化算法需要的信息，只有后端翻译的信息。这样做有一些缺点：
* 中端实现变得臃肿，你可以选择把中端需要的子类和后端需要的子类分开放，但是这样会让编写后端子类更加痛苦，并且无法解决下面两个问题
* 继承的含义变得模糊。在中端层面上，继承都是在暗示从优化算法看来的一致性：所有`Instr`的子类都有一组要读的寄存器和一组要写的寄存器，所有`SetValue`的子类都用一个（概念上的）值更新一个（概念上的）寄存器的内容，等等。然而继续往下，后端在中端基础上的继承却有着截然不同的含义。所幸这次我设计的指令种类特别少，否则就会像上次一样导致整个模型摇摇欲坠
* 前端因此而难受了起来。前端必须选择合适种类的后端子类创建实例，这要求前端对后端有充分的掌握，大大加剧了前端的负担。的确，前端不可能什么附加信息都不提供，但是将指令本身的类型绑定起来实在太僵硬，比如说，想要在前端生成完基本块、中端做完优化以后动态地指定编译到C还是Rust就变得几乎不可能了。

仔细想了一晚上以后，我灵机一动！然后！重新发明了策略（strategy）设计模式……我就知道这么好的点子一定被人发明过了。具体的来说，我给指令的基类`Instr`和值的基类`Value`各添加了一个属性`aux`，表示「与优化无关的辅助信息」。为了避免循环依赖，我允许这个属性值为`None`。这个属性对象可以（像现在的实现一样）包含具体的实现信息，也可以仅仅起到分类的作用，等到进入后端流程了以后再搭配一个工厂模式来创建真正的实现类——事实上这个工厂现在已经在试运行了，用来把`None`填补起来。最重要的是，属性名字`aux`暗示了它是一个通用的辅助信息，今后如果我们需要从前端「夹带」更多的信息到后端去，比如调试信息之类的，都可以通过拓展这个属性的对象来实现，一劳永逸地再也不用去碰基本块数据结构。

----

语法制导的翻译，以前会给我留下印象，完全是因为龙书的封面。我一直都很疑惑，为什么在我看来平平无奇的一章会被印在骑士的盾上象征打败恶龙的强大法宝。现在我明白了，也许它不是最强大的工具，但是的确是最让人有「救命恩人」感觉的工具。

使用语法制导的翻译，让我们在翻译每一条指令时，除了它本身包含的信息，还有机会用到它的根节点流传下来的全局信息。这样一来，一个对哈希表的查询指令就可以知道自己要使用的键和可能查到的值分别是什么类型。同时，语法制导的翻译还允许我们将一个节点的所有子节点翻译完成后，有一个将它们的翻译结果「合成」起来的过程，这样我们就可以每遇到一个需要生成函数的指令就无脑生成一个函数，只要我们最后在合成过程中将冗余消除就好。嘛，说起来轻轻松松，但是这个视角的转换是真的很重要。

因此，为了实现前半部分，将全局信息流传下来，我使用控制器模式，将递归向下翻译的控制流实体化，从而找了个地方把这些全局信息存储了起来。由于这种控制器其实提供信息的意义远远大于控制（它根本没有任何动态改变控制流的功能，每一条指令还是按照既定的顺序在翻译），所以我称之为`Context`而不是`Controller`。为了实现后半部分，将各个指令的生成结果进行合成，我（打算）创建一个数据结构，用来储存「这个指令想要对整个翻译贡献些什么」，这里的「贡献」可以是普通的代码，可以是变量和结构体的声明，还可以是辅助函数的生成，总之是和C语言高度绑定的。然后这个数据结构是根据composite模式的，它是可组合的，组合的过程自然就是我们想要的「综合」步骤了。

最后简单的总结一下。常常有一种论调认为设计模式是一种与算法完全脱节，完全是为了包裹业务逻辑的存在，这种偏见在Java的攻击者当中尤为常见。然而我认为，恰恰相反，设计模式是算法与业务之间的桥梁，是让理想世界中的算法逻辑可以为肮脏的现实世界所用的有力工具。在合适的地方巧妙地塞进去一个设计模式，不仅仅会让代码在规模变大时保持架构稳定，也可以让算法以更适合于实际问题的方式呈现。