---
title: 基于原型继承的脚本语言
date: 2020-04-24 11:33
categories: thoughts
tags: 脑内编程 JavaScript
---

我对原型继承是有执念的。很强的执念。

这种执念一方面出自既成事实。Python，Ruby，以及任何不太玩具的带有厚重运行时的脚本语言，从本质上来说必然是基于原型继承的，只是出于某种历史原因而非常羞于承认这一点。说真的，只要class object出现在文档里，那么再想嘴硬就很难了。我使用Python最多，所以就主要以Python展开接下来的讨论。

为什么要搞不平等？同样是对象，为什么有的对象用`class Foo`的语法创建，以驼峰法命名，有的对象就要以`foo = Foo()`创建，以下划线分割法命名？

> 是的我知道`type`函数，这正是我论证的目的：消除自欺欺人的`class`语法糖，转向全面尊重原型继承的语法。

阶级不平等的好处是生产力。通过人为地将类对象以「高对象一等」的尊贵语法强调，可以简化程序的心智模型。把世上的所有事物分成两类，一类是「实体」拥有内部状态，另一类是「类别」用于解读实体包含的状态，基本上就能对整个世界进行抽象了。

<span style="font-size:8em">真的吗？</span>

正如我上一篇文章中所说的，通过给每个实体一个「种类」是错误的抽象方式，而正确的做法应该是以每个实体所拥有的功能进行抽象。这不是一个集体主义的主场，我们并不需要千人一面的对象大军，我们只关心被传进方法的那一个对象到底像不像鸭子就行了。

> 写到这里需要想起了老大哥COM，所有对象都会实现一个`IUnknown`接口，这个接口要求实现一个`queryInterface`方法，「你实现了我想要的接口吗？如果实现了就请变成那个接口。」说到底就是在静态类型语言里巧妙地模拟基于功能抽象的duck typing。

> 话说回来，COM文档什么时候接着看呢……

----

这不是说原型继承的语法一定好，但是基于类的语法一定是禁锢了思想的。思考一个这样的场景：

```python
class Foo:
    def foo(self): ...
    def bar(self): ...

def foo(x): return x.foo()
def bar(x): return x.bar()
```

如果`foo`方法和`bar`方法是完全没有关系的两个功能，甚至两个全局函数的作者根本没有意料到会有一个对象同时拥有这两个方法的话，要怎么用继承去进行抽象呢？怎么写都很做作。

会不会有一种写法又不限制思想又不像原型继承一样低级的写法会有吗？我想是会的，Rust的trait和struct大概就是一套很好的系统。因此，我的目标就清楚了：发明一个运行时像js一样而语法像Rust一样的脚本语言，用js为它写一个运行时。

这篇文章从早上拖到晚上才写到这里，思路早就没有了，所以就先写到这里吧。
