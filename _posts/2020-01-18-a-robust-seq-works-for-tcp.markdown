---
title: 设计一个数据缓冲队列
date: 2020-01-18 18:18
categories: weaver
tags: C 数据结构
---

[weaver](https://github.com/sgdxbc/weaver)项目后端的一个重要组成部分是`seq.h`，其中实现了一个数据缓冲队列。首先我们来梳理一下这个库需要满足的需求和提供的功能。

一个TCP流的数据包可能以任意顺序到达。对于上层应用来说，它不太关心每次获得的数据量，只要它**获得的数据是完全按照顺序的**：如果一个数据包比另一个数据包后发出，那么这个数据包的数据一定不会先被交给上层应用。

因此，我们的数据缓冲队列需要提供两个核心方法：`Insert`方法将一段数据放入队列；`Assemble`方法将尽可能多符合上述条件的数据从队列中移出并返回给调用者。

比如说，一条流的数据包按照先后顺序编号，并按照1、3、4、2的顺序被`Insert`。如果`Insert`和`Assemble`被交替调用，那么：
* 第一次`Assemble`时，数据包1被返回
* 第二次`Assemble`时，虽然数据包3在队列中，但是由于数据包2缺失，因此没有任何数据被返回
* 第三次`Assemble`时，同样没有数据返回
* 第四次`Assemble`时，数据包2出现，2、3、4被一起返回，队列重新清空。

----

首先我们来考虑一个简化版的队列模型~~来认清这个问题的复杂性~~。

对于每一段数据来说，它有两个属性：长度和偏移，以及数据本身。有些时候我们并不关心实际数据，仅仅想知道类似于「是不是所有的数据都收到了？」这样的问题的答案，因此下面的讨论中我们会暂时忽略数据本身。因此，`Insert`函数接受两个参数`Insert(offset, length)`，其中`length`就是这段数据的长度，而`offset`是数据在整个数据流中的位置。对于`Assemble`函数来说，它不需要任何参数，在不考虑实际数据的情况下，也不需要返回任何值。

在`Assemble`函数中，我们要怎么知道自己缓存的一段数据是否应该被返回呢？为此，我们需要记录一个「队列偏移」值，它的含义是「在这个偏移以前的数据都已经被顺次交给上层应用了」。这样一来，如果队列中的任何一段数据的左端与「队列偏移」相同，那么我们就应该将其从队列中移出，并且将「队列偏移」值更新为这段数据的右端偏移。

为了进一步简化`Assemble`函数的实现，我们进一步规定，缓存数据段要满足以下要求：
* 所有的缓存数据段排成一个列表，依次记录每一个数据段的左端偏移和右端偏移，左闭右开
* 每一个数据段的右端严格大于左端，即长度非零
* 相邻的两个数据段，前一个的右端严格小于后一个的左端，即它们之间必须存在「缝隙」
* 第一个数据段（如果存在）的左端不小于「队列偏移」

这样一来，`Assemble`方法的实现思路被简化为两步：如果没有缓存任何数据段，或者第一个数据段的左端没有与队列偏移对齐，那么不移出任何数据；否则，将第一个数据段移出，并且将队列偏移与被移出的数据段的右端对齐。

接下来，让我们分情况讨论，在`Insert`面对各种情形时，如何使缓存数据段保持上述性质。

----

首先是偏移量`offset`的不同情况。如果`offset`小于队列偏移，那么，被插入的数据中包含了*被我们认为已经递交给上层应用的部分*。于是，这一部分应该被判断为「重复插入」。由于我们已经把上次收到的这部分数据交出去了，因此我们无从得知两次插入的数据内容是否一致——就算我们真的考虑了数据也是如此。在妥善地将重复插入的数据交给上层应用处理后（其中细节超出了本篇文章的范围），我们将这部分数据从插入数据段中「切除」——将偏移量更新为队列偏移，并从长度中减去被切除部分的长度——然后继续处理。

在`offset`一定不会小于队列偏移以后，我们可以在队列中找到一项`pos`，其左端不小于`offset`。换句话说，在`pos`以前的所有项，都比当前插入的数据段从严格更左的位置开始。

> 当然，我们也可能没有在队列中找到这么一项，那么队列中所有的数据段就都比当前插入的段更「左」开始。

那么，是不是说`pos`之前所有的项都在当前数据段开始之前就结束了呢？对于`pos`之前紧邻的一项`pos - 1`（如果存在）这是不一定的。但是，也仅仅是一项而已。如果`pos - 2`是存在的，那么根据上面的性质，`pos - 2`的右端严格小于`pos - 1`的左端，而`pos - 1`的左端又严格小于当前插入段的左端，因此`pos - 2`（以及其之前各项）一定在当前插入段开始之前就结束了。

因此，对于当前插入段与`pos - 1`之间的关系，我们需要分成三种情况讨论：
* 当前插入段与`pos - 1`之间有重叠部分，我们需要将这一情况通知上层应用，并且有能力确定重叠的内容是否一致；
* 没有重叠，但是两段恰好相邻，即`pos - 1`的右端与插入段的左端相等。以上这两种情况中，我们都应该将插入段与`pos - 1`段合并为更大的一段，以保持所需要的性质。合并只需要将`pos - 1`的右端更新为插入段的右端即可。
* 两段之间有缝隙，则插入段作为单独的一段放在`pos`位置上，原本在`pos`及以后的段顺次后移。

这样一来，插入段（`pos - 1`或`pos`）和之前的各个缓存段的性质得到的满足。那么，插入段将在什么位置结束呢？

事实上，插入段的右端没有任何约束，它可以与后面的数据段形成任何相对关系。因此，对于插入段之后的每一段：
* 如果插入段右端不小于这一段右端，则插入段完整的「吃掉」了这一段，应该将这一段直接移除，并且将这一段覆盖的范围报告为「重复插入」
* 如果插入段右端小于这一段的右端，那么根据性质，插入段右端将小于接下来每一段的左端，因此处理可以到此为止。
    * 如果插入段右端大于这一段左端，说明这一段被部分地吃掉了。将这一段与插入段合并，即将插入段右端设置为这一段的右端，并删除这一段，并且将被吃掉的那一部分报告为重复插入。

如此一来，在新的一段被插入后，原有的性质依然得以维持。

----

这篇文章讨论了缓存数据队列的用途和简化的实现思路。在下一篇文章中将进一步丰富，加入窗口和伪数据段等。

文中并没有指明缓存数据段的存储方式。传统上来说多是以链表进行存放，但是由于上述性质使相邻数据段得以快速合并的原因，符合这些性质的队列中缓存数据段的数目一般都比较少，因此可以使用数组实现，简化实现的同时性能不会有太大的区别。