---
title: 理想的web脚本语言
date: 2020-04-22 12:09
categories: thoughts
tags: 脑内编程 JavaScript
---

一不小心又是一个月过去了。幸运的是，在上一篇文章中大声斥责着「这项目根本写不出来」，刚写完文章就找回了感觉，一鼓作气把项目给写到了底。为了督促自己（尽量）勤奋地度过这段没有 DDL 荒淫无度的生活，决定多多写点东西，最好能像这个博客站最开始时那样，每天都写。

写完了 weaver 以后，我对于（真正有意义的）编程的理解又上升了。不管最初是出于赌气的目的还是真的开了窍，当前版本中长达 1680 行的[compile.py][1]很好的完成了它的使命：大一统地定义了整个项目中所有「可编译单元」的编译逻辑。（事实上作为一个编译器项目，这就意味着超过一半的代码行数都在这一个文件里了。）这一点引起了我很强烈的反思——在此之前，我从来都视这种单个大文件为 shit mountain 的象征。因此，出现了这样一个（只要精心管理）就可以至少拓展到五千行，（除了会卡住 VSCode）几乎没有什么副作用的代码体系，着实是令我震惊的。

总结一下，这个「五千行体系」大概是这样的：所有的业务逻辑都定义在全局函数中，所有的实例方法中只有对全局函数的调用。比较典型的例子是对表达式的编译过程。在`lang.py`中对表达式的定义是这样的：

```python
class AddOp(NumberOpMixin, Op2VirtualMixin):
    # ...
    def compile4(self, context):
        return compile4_op2("add", self.expr1, self.expr2, context)


class LogicalOrOp(NumberOpMixin, Op2VirtualMixin):
    # ...
    def compile4(self, context):
        return compile4_op2("or", self.expr1, self.expr2, context)
```

这里`compile4_op2`刚好可以实现所有二元运算符的编译工作，对于一些奇怪的运算符，会有专门的`compile4_xxx`来实现。回到`compile.py`中来，实际的编译实现是这样的：

```python
def compile4_op2(name, expr1, expr2, context):
    expr1_4 = expr1.compile4(context)
    expr2_4 = expr2.compile4(context)
    return Expr(
        expr1_4.read_regs | expr2_4.read_regs,
        Eval1Op2(name, expr1_4, expr2_4),
        (
            compile6h_op2(name, expr1_4.compile6[0], expr2_4.compile6[0]),
            compile6h_op2(name, expr1_4.compile6[1], expr2_4.compile6[1]),
        ),
    )
```

更多的实现细节（包括所有判断`name`的条件分支）被转移到了`Eval1Op2`和`compile6h_op2`当中去了。而开头的两个对`compile4`方法的调用则对应着前面`lang.py`中的各个对`compile4_xxx`函数的简单包装。

总而言之，这个模式本质上是对面向类/对象体系的一种蔑视：方法具有多态的性质？那好，那么我就只把它当作多态的工具来使用。上千行的`compileN_xxx`当中蕴含着纯粹的结构化编程的精神，而所有的多态都可以一对一地简单转换成函数指针的形式，`class`由一门语言中流砥柱的特性退化成了普通的语法糖。在不涉及内部状态时，这种模式天衣无缝；内部可变状态虽然需要被特殊处理，但是所有的状态都被非常明显地暴露出来了，因此也避免了大量可能的疏忽。

开始下一个部分之前最后补充一句，这种模式是可以兼容类型系统的，只要创建一个纯虚类`Compile4`，然后所有的包装类都继承它，所有的参数类型也都是它就可以了。这个类应该定义在`compile.py`中，这样`lang.py`就可以连同所有的函数一起把它 import 进来。未来对 weaver 的某次整改中我也许是尝试一下。

---

我承认这种模式有它过激的一面。如果退后一步，不强制方法只能是包装的话，这种模式其实本质上只是在要求建模顺序倒置。程序员应该先去探索多态存在的迹象，然后根据场合将其总结成合适的虚类/接口，而不是先制定一个看似严密的「世界」模型，然后根据每一个类所处在的「层级关系」去思考它需要实现的接口应该怎么实现。这在一定程度上类似于「要as-a不要is-a」的信条——这也许是世界上认同者与实践者差值最大的信条之一。

当程序员遵循这种顺序构建程序模型时，他首先会感觉到失望——程序再也无法「仿真」真实世界了。当你去创建一个「鸭子」类时，它需要继承/实现的是「会叫」类，「会游泳」类，乃至「肉能吃」类，而不再是「动物」类——除非「动物」类只是对以上三者的简单组合，而这显然是错误的。类型系统的约束不再尝试去探寻所谓「世界的本质」，反而变得「浮于表面」，仅仅是在实现功能/功能集合的层面上对类的实现提出要求并且对类的用户提供保障，非常不思进取，但也非常实用。

> 也许很多准程序员或早或晚都会换上程序员独有的中二病：习惯于以程序建模的手段来对真实世界建模，并指导自己思考的逻辑。对于现实生活这样是有害的——会越活越像机器人，对于写程序这样也是有害的——会使得解决程序问题时建模的手法越发的「本质」，而正如上面所论述的，这其实是面向对象编程的anti-pattern。所以说，早一点看清机器的能力边界吧，有百益而无一害。

如果上面的描述听起来太朦胧了，那么我坦白，我所描述的其实和Rust的trait系统基本上是一致的。事实上，我之前真的写了一篇[文章][2]讨论怎么在Python中用Rust的思路去建模。当初的想法稍微有点理想化，不过大体上是实用的，毕竟到今天为止这一版weaver还没有引起我的反感不是。

----

文章已经接近尾声，读者估计已经傻了，说好的web呢，怎么就标题党了？事实上是这么一回事。我筹划了一个网页端小游戏，但是每写到几百行的程度就由于受不了js的方方面面而失去动力。虽然现在的我已经没有精力去写这个游戏了——或者说，反正连写游戏的精力都没有了——不如把饼画得再大亿点点，设计一门能让自己可以忍受的编译到js的语言吧！

对于这门语言，除了一些细节上的怨念：内建的哈希表的键应该支持任何对象，相等运算符要符合直觉等等以外，还有两个设计上希望能实现的愿望：上文中论述的模式可以用起来舒服，以及真正的基于原型的继承，这一点放在下一篇文章中再写吧。

[1]: https://github.com/sgdxbc/weaver/blob/888f267a1a4342bf2325a1cd680575318b329933/weaver/compile.py
[2]: https://zhuanlan.zhihu.com/p/105890016