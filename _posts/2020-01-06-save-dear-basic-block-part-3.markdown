---
title: 拯救基本块大冒险！最终话
date: 2020-01-06 18:28
categories: weaver
tags: Python PyCharm 优化
excerpt_separator: <!-- more -->
---

> 从邪恶的魔王被勇士打败后，一年过去了。

好吧，就算不采用这种误导人的说法，距离[第二话][1]也有一周以上的时间了。在此期间，基本块算法所在的`code.py`几乎再也没有任何改动，让我逐渐相信它将会长期稳定。因此，我在这里写下一些不会被时间推翻的，结局之后的话。

<!-- more -->

在此之前，我想稍微提及一些之前略过的细节。

## 非主流`SetValue`：`Command`

我在前面的文章中有提到，`SetValue`是中间表示仅有的两种指令中唯一「真正」起到作用的一种（`If`起到的作用对于最终只推了一条线的程序来说应该算是隐形的）。它需要读取零到多个寄存器的值，并且更新一个寄存器的值。它有一个子类`Command`，这个子类所更新的寄存器属于「抽象」寄存器，比如`runtime`，`sequence`之类的。这类寄存器实际上并不存在，只是为了将对命令的使用纳入我们的模型内——有了这些寄存器，两条调用同一个「抽象」寄存器上提供的命令的指令就不能颠倒执行顺序，对这些寄存器的读取操作也会被限制住，从而（比如说）避免在解析一个数据包（由`header_parser`寄存器提供的命令）之前就读取了数据包的内容（一个需要读取`header_parser`寄存器的值，虽然这个寄存器在实现的各个层面上都和这个值没有关系，只是逻辑上的读取）。

因此，`Command`有一个特性：它**不可能**将任何寄存器的值常量化——说到底，它会写的寄存器都是抽象寄存器，本来也不存在，更不用说它们的值了。

由于这种「不会产生常量」的特性，当我们遇到一个`If`，而这个`If`的某一个分支上包含`Command`指令从而对抽象寄存器形成写依赖时，我们依然可以不把它当作`Choice`而展开它。因为归根到底，我们想要展开`If`的目的就是用它的内容来拓展我们的常量表，但是触摸到一条`Command`指令是没有这种可能的。

这个避免展开的逻辑最终出现在了分支定位的后向依赖构建算法中——这里是我们发现漏网之鱼`Choice`的地方。最终这个优化也对我们的成功起到了很大的帮助。

## `Command`拓展阅读

在对`Command`进行运用编写应用代码时我遇到了一点难题。

我有一个抽象寄存器`instance_table`，它是一个存放了大量实例的哈希表。它提供`Fetch`、`Create`和`Destroy`等典型的哈希表命令来进行操作。在执行了`Create`命令后，一个新的实例被创建出来，于是属于这个实例的一组寄存器变为可用状态。

> 我对`instance_table`的使用提出了非常严格的限制：同一时刻只能有一个「活跃」的实例，也就是说在`Destroy`之前`Fetch`和`Create`不可以被重复调用。再加上所有实例都是同样的数据结构，因此事实上我可以预先创建出一组寄存器对应于实例中的每一个数据，然后在`Fetch`和`Create`之后就用它们作为界面来操作被找到的或者新创建的实例的内容。

这样一来就有了一个问题：对实例内数据的映射寄存器的更新应该对应着一条`SetValue`指令，可是这个指令应该把谁指定为被更新的寄存器？映射寄存器显然是不能不被指定的，但是如果不把`instance_table`列入被更新的寄存器的话，我们就可能错误地把`Create`或`Fetch`延迟到这条`SetValue`之后执行。编译为两条`SetValue`也是不行的，因为没办法把两条指令「粘」在一起。

最终，我选择把`instance_table`列入读取的寄存器列表。一方面，根据三种依赖中的「写后读」和「读后写」，这样足够保证`SetValue`和`Create`、`Fetch`以及`Destroy`的顺序；另一方面，考虑到最终编译出的代码：

```c
inst = Create(...);
inst->x = y + 1;
```

如果说对映射变量的更新实际上只是对`instance_table`（所提供的`inst`）的读其实也说得过去——只是这个读发生在了等号的左侧而不是右侧罢了。

## 对象复制与算法终止条件

在我的实现中，算法的驱动函数非常暴力

```python
    def optimize(self) -> BasicBlock:
        block = self
        while True:
            opt_block = block.eval_reduce().relocate_cond()
            if opt_block is block:
                return block
            block = opt_block
```

是的，直接用`is`来判断是否发生了进一步的优化。这实际上意味着两件事：
* 如果想要更新某个基本块的内容，必须重新创建一个新的基本块，不能就地更改，否则上层函数就会丢失「它被更新了」的信息
* 如果没有发现新的优化，**必须返回原来的基本块**，否则算法就停不下来了

顺便一提，事实上所有的指令对象都是复用了最初传进来的代码列表中的那些对象，没有任何复制，也没有任何修改。这种静态数据的模型对于写对一个大型算法至关重要，同时还提升了它的性能。

在常量分析中，想要判断是否发现了新的优化点比较简单：
* 如果当前基本块没有条件判断，那么必然没有优化空间
* 如果条件判断的结果可以静态确定，那么必然发现了新的优化——因为这个条件直接被消灭了
* 如果上面两者都不是，那么如果两个后续块中发生了优化，自身就算作发生了优化——这样就可以将递归链条末端发现的优化向上传递了，同时也是因为我们的数据结构是不可变的，想要将后续基本块更新为优化过的新版本就只能创建一个新的基本块

而在分支定位中，最朴素的实现**总是会创建新的后续基本块**，因为我们需要将不必须在当前块中完成的指令放进后续块中去，因此上面的判断条件会失效。所以我们需要在创建新的后续块之前先确认一个当前块是不是真的有拿到后面执行的指令，如果有再创建后续块——并且默认这时发生了优化。其他判断与上面类似。

## 总结

### 优秀的数据结构是一切优化的先决条件

这个结论看起来很厉害实际上没什么用——因为我并没有说清什么是「优秀」的数据结构。粗略地来讲，最适合算法、能让算法的表述最简单的数据结构是最优秀的，因为优化的前提是原来的代码你还能看得懂。

### 追着热点优化，而不是代码的复杂程度和其本身的执行效率

这次优化成功的一大原因就是PyCharm的profile功能还好用——如果像测试覆盖率工具一样down掉了我可能就再也没机会写这几篇文章了……

一段代码再复杂，运行起来再低效，只要我们的程序在运行过程中执行它的机会足够少，我们就可以也应该忽略它。而与之对应的，如果一段代码确实花费了99%的执行时间，哪怕它已经完美无瑕，我们也必须打破它，哪怕为此再去写好几段前面一种代码也必须如此。

### 基于写文章的调试方法

在写这几篇博客的过程中，我又对整个算法进行了一定的改进和修正。真的有用，值得一试。

[1]: {% post_url 2019-12-27-save-dear-basic-block-part-2 %}