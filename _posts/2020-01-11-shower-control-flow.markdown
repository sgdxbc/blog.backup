---
title: 淋浴式控制流
date: 2020-01-11 20:22
catogeries: weaver
tags: goto C
---

基本块数据结构的控制流具有有一种天生的编译方式：在每个基本块开头放置一个标签，然后用`goto`跳转到合适的基本块去。这篇文章主要讲一讲怎么把这种编译方式拓展一下，使它可以模拟函数调用。

开始之前先回顾一下基本块的一个重要特性。对于使用`BasicBlock.from_codes`方法构建出来的基本块簇，每个基本块不会被复用。整个程序运行的过程中，每一个基本块最多被执行一次，并且在每一次执行中，每个基本块的前序基本块都是相同的。

----

有这样一条命令指令`Next`。它的作用是「调用」另一个基本块簇。详细的来说，当前基本块簇的状态被保存下来，被调用的基本块簇从入口块开始执行，直到任何一个没有后续块的基本块执行完毕。然后，原本的当前基本块簇按照保存下来的状态继续执行。

一般的想法自然是用真正的C语言函数调用来实现。然而，不管你信不信，所有的基本块簇居然共享一个寄存器空间——就比如说，TCP基本块簇的指令会去读取IP基本块簇拥有的寄存器来确定当前数据包的源IP和目的IP。因此，一旦用了函数调用，那么（在C语言的语境下）我就只能用全局变量来存放寄存器了。我并不愿意这样做，哪怕是生成出来的代码也不愿意。

因此，我决定把所有编译出来的基本块簇都放在同一个函数体内，然后将`Next`编译成`goto`带上一些附加操作。这样做的代价有两个：
* 每个基本块不再拥有唯一的前序基本块，具体地说，每个簇的入口块可能又多个`Next`到达
* 每个基本块不再最多只被执行一次。

对于第二个代价，实际上分为两种情况，我们先讨论简单的情况：包含`Next`命令的基本块会被执行两次，其中第二次是从`Next`之后紧跟的指令开始执行。对于这种情况，我们可以在`Next`编译成的`goto`之后加一个标签，然后在执行完被调用的簇之后再`goto`回来就可以了。

这时候第一个代价出来刁难了：被执行的簇可能被多个`Next`指令调用，它要怎么知道返回的是哪个基本块呢？

这可以通过一个特殊寄存器`ret_target`来解决。我们在`Next`编译的`goto`之前插入一条赋值指令，将`ret_target`的值赋为当前基本块的ID（刚好每个基本块都有全局唯一的ID），然后在退出被调用基本块时按照`ret_target`的值决定`goto`的标签，这将是一个稍微有点规模的`switch`语句。为了减小生成的代码量，我专门设置了一个「淋浴喷头」块用来包含这个`switch`语句，在任何一个作为簇终点的块的末端都会跳往这个淋浴喷头，然后再由喷头将控制流「洒」向合适的块——上一个簇中的某个`Next`之后的标签。

> 「淋浴喷头」块不是一个基本块，而是一个C层面的块，也就是一个标签加上一段代码。

----

接下来还要作两点补充。第一个是关于实现多层调用。这要求我们用一个变量保存上一个`ret_target`值。通常来说这里都是必须要有一个栈的，但是我们有一个优势：每一个基本块只会**从头**进入一次——包含`Next`的块的二次进入是从半途中的。因此只要为每一个包含`Next`的块都创建一个变量，就可以确保每一次`Next`备份的`ret_target`都存放在不同的变量中。

第二个是有关「第二个代价」的复杂情况：由于递归调用导致的多次执行同一个基本块。这基本上会打破我们上面的所有前提，幸好我所面对的需求有一个优势，那就是它事实上可以被尾递归优化。因此，我只需要忽略备份`ret_target`的操作，直接装作没有执行过正要被递归的簇就好。