---
title: TeaScript的语法设计
date: 2020-05-12 12:34
categories: teascript
tags: Python JavaScript Ruby
---


写着写着词法分析忽然发现居然还可以水一篇博客。如今TeaScript已经拥有一个简单的抽象语法树，并且已经可以解释执行这个语法树。可以说，就差一个从代码字符串生成语法树的分析器，就可以开始用来写点程序了。

顺便一提，语法树是真的很简单。节点大体上分为表达式和语句两种。比较特别的是`Spawn`和`Dispatch`，分别用来生成新的对象和将消息分发给一个对象。然后是用来读写作用域内名字的`LoadName`和`StoreName`，和用来读写方法所属对象的内部状态的`LoadState`和`StoreState`。然后是两个读操作，`LoadContext`用来获得上下文对象，`LoadArg`用来在方法内部得到被分发到的消息携带的参数，这个节点主要是为了降低`Spawn`的复杂度——事实上，如果一个方法是形如

```
foo(arg1, arg2) -> 
  ; ...
```

会固定的生成`StoreName('arg1', LoadArg(0))`和`StoreName('arg2', LoadArg(1))`在所有语句之前。除此之外是一些常见的`If` `While` `Return` `Break`和`Continue`。最后是一个`Native`语句作为运行时开的口子。就这些，没有了。

进入正题之前最后插一嘴，一般的面向对象语言，在方法内都有一个谜之上下文`this`或者`self`，它所引用的对象随着调用方法的对象变化而变化。在TeaScript（的实现）中这对应着`receiver`， 指最初发起消息分发的对象。此外还有一个`responser`对象，是真正持有内部状态的对象，也就是定义这个方法的`Spawn`表达式所返回的对象。上下文对象和内部状态来源的对象不是同一个对象这回事可能会让人感到有点迷惑，不过一旦这个设计被证明是一个真正好用的创意，那TeaScript大概就可以算是我留在世上的第一个代表作了。

----

上面把所有表达式和语句的语法节点列了一遍，抛开那些任何语言里都有的节点——要是把`break`改成`escape`那估计这语言就没人用了——最主要的语法设计在以下这些节点上：`Spawn` `Dispatch` `StoreName`和`StoreState`。设计中要考虑的一些事：
* `Dispatch`几乎在所有的语言里都是用`.`操作符，还有少量语言用`->`操作符表示的。
* `Spawn`的设计没有什么可以参考的先例。考虑到我一直在用「分发消息」「接收消息」的字眼来形容方法调用，那么Erlang中的`receive`语句内部结构用到定义方法体的部分还是合情合理的。
* 我了解到的所有语言都在把`=`（最多就是`<-`和`:=`）用在包括`StoreName`和`StoreState`在内的所有赋值场合，但是我下定决心要把这两者尽量做到差异化。↓这得多说两句。

每次有只会C的小白刚开始学Python时，总是会抛给我一个千变万化的问题，殊途同归地，这个问题的核心在于

> C的变量是个内存格子，而Python的变量没有格子，只有名字。

注意，我不是在说Python没有格子。Python的格子都是属于垃圾收集器的，而不是属于作用域里的各个名字的。但是如果是对象的内部状态，那么就可以把它看作是一个格子

```python
def foo(a, b):
    a = 42  # 对原来的a没有影响，因为a不是格子
    b.c = 42  # 改变了原来的b，虽然b不是格子，但是b.c可以看作是格子
```

虽然写多了以后就知道这两个等号完全不是一样的含义（后一个甚至可能会变成`__setitem__`之类奇怪的东西），但是对于新手来说真的很困惑。

在TeaScript中这种差别甚至被我人为扩大了：`StoreName`没有格子，而内部状态根本就是一个格子。说实话，如果要是方便的话我都想要把`LoadName`和`LoadState`的语法分开，但是这的确可能是个难以实现的愿望。

----

总体上来说，有两种大的设计风格的方向：一种用符号，一种用单词。大体上来说现在的主流都是用单词的，但是会有如Ruby的继承用`<`，JavaScript的`import * as xx from ...`，以及古老的Self的`^`作为方法返回的关键字。多用符号可以让代码更加简练，看起来像数学公式一样又优雅又让人有点望而却步——就像Haskell那样。不过呢坏处也很明显，首先肯定不能把所有的关键字都用符号来表示——例如那群`break` `continue` `return`之流。然后符号的出现会让代码不好念出来，比如读C代码的时候遇到引用地址和解引用操作，念法就变得抽象了起来。所以说，虽然用`&&`代表上下文对象，用`&foo`引用内部状态看起来很帅，但是我还是倾向于用单词做关键字。

这个观点的一个很重要的后果就是对`Spawn`的语法设计。生成一个对象需要三个信息：它的监督者是谁（「监督者」这个名字可真得换一换了），它拥有哪些内部状态，以及它能收听哪些消息。关于内部状态，其实它的声明并不重要——当然，提前声明可以节约读代码的人大量的时间，重要的是我要给内部状态一个初始化的机会，就像Python的`__init__`一样。因此，一个`Spawn`对应着代码中的一大段。基于单词关键字的写法大概可以是这样的

```
spawn on watcherObject
  initialize
    &state1 to 0
    &state2 to 42
  receive
    foo then
      return &state1
    setState(state) then
      name bar to state + &state1
      update &state2 to bar
```

这里顺便给出了`StoreName`和`StoreState`的写法。大概有了高亮的话就会好看很多吧。这样写的坏处自然就是很长，所以还是用了`&foo`来表示内部状态。

忽然不想写了就这些吧。哦对了最后说一句，我的确打算用类似于PureScript那种用缩进表示块的做法。但是我不想像Python一样在末尾加冒号，因为这个冒号就只有允许不换行的作用，但是基本没有会真的不换行的情况吧。

> Written with [StackEdit](https://stackedit.io/).
