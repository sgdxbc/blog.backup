---
title: 减少基本块结构的内存消耗
date: 2019-12-24 15:08
categories: weaver
tags: 编译器 优化
excerpt_separator: <!-- more -->
---

![内存消耗突破天际](/assets/Annotation 2019-12-24 150450.png)

> SSD：「撑住！我来了！」CPU：「……你还是算了吧」

<!-- more -->

在之前的两篇文章中，我介绍了[一种用于优化的基本块数据结构]({% post_url 2019-12-20-a-simple-ir-for-optimizing %})，和[操作基本块的两种算法]({% post_url 2019-12-22-constant-evaluation-and-condition-relocating %})。这些技术在面临问题规模的增长时，时间和空间复杂度都会呈指数增长的趋势，因此限制问题的规模至关重要。这篇文章将讨论如何在（尽量）不影响优化结果的情况下，将问题规模降低至可以接受的程度，并且回答一个读者也许早就想问我的问题：

### （我所定义的）常量分析和分支定位到底进行了什么优化？

我想读者也许早就发现了这个问题。分支定位显然不会进行任何优化；它只能改变程序的执行顺序，而无法消减任何代码。常量分析的结果并没有保存下来，仅仅是将其判断结果可以静态确定的条件分支的判断连同一条本来就永远都不会进入的路径给消除了。如果只是到此为止的话，也许这一系列的文章被称为是「代码尺寸优化」才更加合适一点。

事实上，经过循环执行两种优化以后，程序变形成为一种有趣的等价形式，在这种形式中，**基本块中的指令尽可能地集中了起来**。也就是说，不管你顺着哪一条分支观察程序的执行流程，都会发现，绝大多数的指令都是在一个基本块中被执行掉的，在此之前可能会出现多个空壳基本块，只包含条件判断而不在此之前执行任何指令。

> 当然，只有在原本的程序逻辑允许这种现象发生的那些分支，才会发生这种现象。

这种集中性使我们有机会发掘出原本零散地分布在程序中各处的冗余操作。例如，以下是对一个IP协议解释器的真实实现进行优化后得到的其中一个基本块

```
L5136:
$1001 = 0
$1000 = 0
$1001 = 1
$1001 = 1
$1000 = 0
$101->Create(header->saddr, header->daddr)
$1003 = 0
$102->InsertMeta(header->offset, header_meta->payload_length)
$102->InsertData(header_meta->payload)
$1002 = 0
$102->Assemble()
$101->Set{state}($1000)
$101->Set{seen_dont_frag}($1003)
$0->Next()
$101->Destroy()
```

除去显而易见地对`$1001`的重复赋值（事实上，由于接下来并没有依赖与`$1001`的值的逻辑，所有的赋值都是多余的）以外，我们可以发现一对方法调用：`$101->Create(...)`和`$101->Destroy()`。我们可以基于这个信息，将一个昂贵的`Create`方法调用替换成为一个等价的`Fake`方法——只有在我们知道接下来`Destroy`方法会被调用的时候才能这样做！如果这个基本块位于一条执行概率非常大的分支上，那么以上操作将会使程序性能得到巨大提升。

这就是我们执行两种基于基本块的优化的最终目的。

----

程序执行流上每出现一个条件分支，其合并后的所有指令就都需要复制成两份。在一条较长的、途径多个「菱形」结构的控制流上，后续的指令将在基本块中占据极为庞大的内存。因此，如果我们可以将不影响优化结果的条件分支保持为「折叠」状态，就可以节省大量的内存空间和计算时间。比如

```c
int x, y, z, w;
sys->Create();
if (x == 0) {
    w = z + sys->status;
}
if (y == 1) {
    // ?
}
if (z == 1) {
    sys->Destroy();
}
```

在这个例子中，`Create`和`Destroy`在同一个基本块中聚首看上去相当有希望，除非——问号处对`z`的值进行了修改。一旦`z`在问号处被修改，这个赋值操作就无法被移动到最后一个`if`判断之后——也就是移动到最后一个基本块内。同样的，由于被这次修改「卡住」，在第一个`if`中对`w`进行的赋值操作也无法向下移动（到最后一个基本块内)，而这次赋值涉及到对于`sys`的读取，因此也「卡住」了其上方对于`sys`方法的调用——那相当于对`sys`的一次写入。反过来，如果问号处没有对`w`的值进行修改，那么这段程序就可以变化成

```c
int x, y, z, w;
if (x == 0) {
    if (y == 1) {
        if (z == 1) {
            sys->Create();
            w = z + sys->status;
            // ?
            sys->Destroy();
        }  // 其它情况……
```

这是我们仍然按照原来的方法，展开所有的条件分支所能得到的结果。我们还可以把这段程序变换成

```c
int x, y, z, w;
if (x == 0) {
    if (z == 1) {
        sys->Create();
        w = z + sys->status;
        if (y == 1) {
            // ?
        }
        sys->Destory();
    }  // 其他
```

在这种情况下，整个优化过程中没有对`if (y == 1) { ... }`的内部结构进行任何探索，事实上，这个`If`指令被完全当作了一条`SetValue`来对待。如此一来，我们就成功地达到了最初的目的：将条件分支「折叠」起来而不影响最终的优化结果。

----

在这篇文章中我们看到了「对优化过程进行优化」的可能性，weaver项目系列文章的下一篇将具体描述优化的方法。在这篇文章的最后，我们来讨论一下对于优化算法正确性的定义。

最为显而易见的正确性是生成程序的逻辑正确性，也就是说，优化生成的程序应该与原来的程序的行为完全一致。事实上，无论将一个程序的条件分支展开到怎样的程度，只要进行的变换操作只有上篇文章的所描述的两种算法，这种意义上的正确性都是可以得到保证的。

假如我们将经过了上一篇文章中所描述的流程，「完全地展开一段程序，循环执行两种算法直到程序不再发生变化」，所生成的程序称之为最优程序，那么，对优化过程正确性就可以从另一个层面进行定义：「达到最优」。这种「达到」并不一定要求优化后的程序和最优程序一模一样，而是说，优化后的程序可以暴露出全部的优化机会。比如在上面的例子中，后一种优化后的形式虽然和前一种（最优的）形式不同，但是`Create`和`Destroy`依然在同一个基本块内，就可以算是完成了正确的优化。

在保持上述第二种正确的前提下尽可能地折叠条件分支，就成为了我们接下来的目标。
