---
layout: page
title: 在线性中间表示中进行常量分析和分支定位优化
date: 2019-12-21 17:39
author: sgdxbc
categories: weaver
tags: 编译器 Python
toc: true
---

在[上一篇文章]({% post_url 2019-12-20-a-simple-ir-for-optimizing %})中我介绍了一种用于优化的中间表示，这次我将继续讨论如何在这种中间表示上进行优化。

## 常量分析

通常来说，常量分析主要用于在编译时计算复杂表达式的值，从而节省运行时的CPU时间。然而，[weaver][1]项目并没有这样的需求：所有的表达式都是小而简单的，其中的绝大多数甚至只是将寄存器赋值到常量。因此，本文中的常量分析算法并不使用分析得到的常量结果替换赋值表达式。

如果不去记录表达式的值，那么求值还有什么意义呢？我们并不关注求得的值本身，而是着眼于常量值对于控制流分支条件的影响。这种影响分为两种。第一种例如

```c
int x = 42;
if (x == 42) {
    y += 1;
} else {
    y -= 1;
}
```

由于条件分支的判断值是一个编译时可知的常量，因此`else`分支可以被死代码消除技术直接消灭。进一步的，如果在进入这段程序之前的`y`值是已知的，那么这段代码执行过后的`y`值也就被这次优化给确定下来了，从而成功地扩大了已知常量的范围。

以下是第二种情况

```c
if (x == 42) {
    y += 1;
}
int z = x + 1;
if (z == 43) {
    y -= 1;
}
```

在这种情况下，我们无法确定程序开始时`x`的值，从而无法判断第一个`if`的判定条件是否成立。但是，这次判定会带给我们更多的信息。如果控制流真的进入了这个`if`，那么我们可以据此推断出`x`的值一定时`42`，从而可以得出，接下来`z`一定会被赋值为`43`，那么下一个`if`判断就满足了上面提到的第一种情况，从而可以不再进行判断，直接执行`y -= 1`的操作。当然，这一切都是基于我们最初的假设，即控制流会进入第一个`if`。如果控制流没有进入第一个`if`，那么我们就无从确定`x`乃至`z`的值，对于第二个`if`也就无法执行上述的优化。但是我们同样可以基于第二个`if`的内容，假设控制流进入了其中，从而得知`z`一定为`43`，进而对后续代码再次进行这种分析。

通过上面的描述，我们可以发现，虽然代码`int z = x + 1;`写出来只有一行，但是对它进行的分析结果与其之上所有的条件分支密不可分。这便是`BasicBlock`数据结构的一个设计目标：在将以上代码标准化为`BasicBlock`结构时，`int z = x + 1;`将会被复制为两份，一份紧跟第一个`if`条件成立的情况，另一份则紧跟`if`不成立的情况，从而便于进行两次互不影响的优化分析。

## 分支定位

在上一篇文章中定义的简单中间表示中只有两种指令：`SetValue`用于设置一个寄存器的值，而`If`用于创建条件分支。在转化为`BasicBlock`以后，所有的`If`都成为基本块的「分割线」，每个基本块中的指令列表实际上就只剩下`SetValue`了。

每一个`SetValue`指令实际上需要读取零或多个寄存器，并写入一个寄存器。同样，每个`If`的判断条件值（也就是基本块的判断条件值）也需要读取零或多个值。这种读写关系使各条指令之间形成了一些顺序依赖。比如

```C
int a = b + 1;
int b = c + d;
int e = b - 1;
if (a > 0) {
    // ...
```

对`a`的赋值必须在对`b`的赋值之前完成，否则对`a`的赋值将错误地使用`b`的「新版本」。对`b`的赋值也必须在对`e`地赋值之前，否则`e`将使用`b`的「旧版本」。然而，最后的条件分支可以放置在对`a`的赋值之后的任何位置，这并不会改变条件分支的判定结果。

总结起来，顺序依赖共有三种：
* 对同一个寄存器写之后读，改变执行顺序可能导致读到过旧的值
* 对同一个寄存器读之后写，改变执行顺序可能导致读到过新的值
* 对同一个寄存器写之后再写，改变执行顺序可能导致写入过旧的值

> 在编译器优化和CPU乱序执行的语境下通常将后两种依赖认定为「伪」依赖，并通过寄存器重命名等技术将其消除。由于这种「消除」对于这篇文章所要解决的问题实际上没有意义，因此不作展开讨论。

对于没有以上这些依赖关系的任何一对指令，我们可以随意决定它们谁先执行谁后执行，而不会导致程序执行的结果与原来的程序不一致。

----

在上述讨论的基础上，我们将尽可能地让所有地分支判断尽可能早地执行。为什么要这样呢？看下面这个例子

```c
int x = y + 1, z;
if (y == 42) {
    z = x + 1;
} else {
    z = x - 1;
}
if (z > 0) {
    // ...
}
```

如果仅仅使用常量分析的方法来优化以上程序，我们事实上一步都无法前进：对于第一个`if`的判定条件，我们没有足够的信息去断言它是否成立；就算通过第一个`if`作出了`y`的值是`42`的假设，它也无法使我们了解到`z`的值，从而更无法在接下来的条件分支中发挥作用。

然而，如果我们观察到第一个`if`的判定与其之前的`int x = y + 1`没有依赖关系，我们就可以尽早执行这一判定，将程序变化为

```c
int x, z;
if (y == 42) {
    x = y + 1;
    z = x + 1;
} else {
    x = y + 1;
    z = x - 1;
}
if (z > 0) {
    // ...
```

接下来就可以顺畅地使用常量分析进行优化了。

## 总结

本文论述了两种基于`BasicBlock`数据结构的优化算法。常量分析尽可能挖掘条件分支所带来的「分支专属」的额外信息；分支定位则使这种信息尽早处于可用状态。

上文中描述了一个具体的，通过调整分支位置而得以触发的常量分析的例子。事实上，常量分支缩减掉不必要的分支判断，也可以反过来为进一步将后续的分支判断提前进行创造条件，比如

```c
if (x == 0) {
    int y = x + 1;
    int w = z + y;
    int y = y + 1;
    if (y > 0) {
        if (z == 0) {
                // ...
```

如果没有进行常量分析，则第三个`if`判断无法被提前至`int w = z + y;`之前。但是在常量分析消除了第二个`if`以后我们便可以这么做了。

> 这个例子还是稍微有点啰嗦了，我相信读者一定可以想出更简练的例子来。

因此，对一段程序执行这两种优化的过程，实际上是轮流执行两种优化，直到程序不再发生变化的过程。

[1]: https://github.com/sgdxbc/weaver